/**
 * Utility functions for exporting maps
 */

/**
 * Generate a PDF export of the map
 * @param {Object} options - Export options
 * @param {HTMLElement} options.mapElement - The map DOM element
 * @param {Array} options.parcels - Array of parcel objects
 * @param {string} options.title - Title for the export
 * @param {string} options.client - Client name
 * @param {Date} options.date - Date of export
 * @param {boolean} options.includeMetadata - Whether to include metadata
 * @param {string} options.orientation - Page orientation ('portrait' or 'landscape')
 * @returns {Promise<Blob>} - Promise resolving to PDF blob
 */
export const generatePDF = async ({
  mapElement,
  parcels,
  title,
  client,
  date,
  includeMetadata = true,
  orientation = 'landscape'
}) => {
  // This is a placeholder implementation
  // In a real implementation, we would use jspdf and html2canvas
  
  // Import libraries dynamically to avoid issues with SSR
  const { jsPDF } = await import('jspdf');
  const html2canvas = (await import('html2canvas')).default;
  
  // Create new PDF document
  const doc = new jsPDF({
    orientation: orientation,
    unit: 'mm',
    format: 'a4'
  });
  
  // Add title page if metadata is included
  if (includeMetadata) {
    addTitlePage(doc, { title, client, date });
  }
  
  // Capture map as image
  const canvas = await html2canvas(mapElement, {
    useCORS: true,
    allowTaint: false,
    scale: 2 // Higher resolution
  });
  
  // Add map to document
  addMapPage(doc, canvas, orientation);
  
  // Add parcel data if requested
  if (includeMetadata && parcels.length > 0) {
    addParcelDataPages(doc, parcels);
  }
  
  // Return document as blob
  return doc.output('blob');
};

/**
 * Generate a PNG export of the map
 * @param {Object} options - Export options
 * @param {HTMLElement} options.mapElement - The map DOM element
 * @param {string} options.resolution - Export resolution ('standard', 'high', 'print')
 * @param {string} options.fileName - Base file name
 * @returns {Promise<Object>} - Promise resolving to {blob, fileName}
 */
export const generatePNG = async ({
  mapElement,
  resolution = 'standard',
  fileName = 'map-export'
}) => {
  // This is a placeholder implementation
  // In a real implementation, we would use html2canvas
  
  // Import html2canvas dynamically
  const html2canvas = (await import('html2canvas')).default;
  
  // Determine scale based on resolution
  const scale = getResolutionScale(resolution);
  
  // Capture map as image
  const canvas = await html2canvas(mapElement, {
    useCORS: true,
    allowTaint: false,
    scale: scale
  });
  
  // Convert to blob
  return new Promise(resolve => {
    canvas.toBlob(blob => {
      resolve({
        blob,
        fileName: `${fileName}.png`
      });
    }, 'image/png');
  });
};

/**
 * Add a title page to the PDF
 * @param {Object} doc - jsPDF document
 * @param {Object} metadata - Title page metadata
 */
const addTitlePage = (doc, { title, client, date }) => {
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  
  // Add title
  doc.setFontSize(24);
  doc.text(title || 'Parcel Map', pageWidth / 2, 40, { align: 'center' });
  
  // Add client info
  if (client) {
    doc.setFontSize(16);
    doc.text(`Client: ${client}`, pageWidth / 2, 60, { align: 'center' });
  }
  
  // Add date
  const dateStr = date ? new Date(date).toLocaleDateString() : new Date().toLocaleDateString();
  doc.setFontSize(12);
  doc.text(`Date: ${dateStr}`, pageWidth / 2, 70, { align: 'center' });
  
  // Add footer
  doc.setFontSize(10);
  doc.text('Generated by Titlesearch Pro Mapper', pageWidth / 2, pageHeight - 10, { align: 'center' });
  
  // Add new page for map
  doc.addPage();
};

/**
 * Add a map page to the PDF
 * @param {Object} doc - jsPDF document
 * @param {HTMLCanvasElement} canvas - Canvas with map image
 * @param {string} orientation - Page orientation
 */
const addMapPage = (doc, canvas, orientation) => {
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  
  // Calculate dimensions to maintain aspect ratio
  const canvasAspectRatio = canvas.width / canvas.height;
  const pageAspectRatio = pageWidth / pageHeight;
  
  let imgWidth, imgHeight;
  
  if (canvasAspectRatio > pageAspectRatio) {
    // Canvas is wider than page
    imgWidth = pageWidth - 20; // 10mm margin on each side
    imgHeight = imgWidth / canvasAspectRatio;
  } else {
    // Canvas is taller than page
    imgHeight = pageHeight - 40; // 20mm margin on top and bottom
    imgWidth = imgHeight * canvasAspectRatio;
  }
  
  // Center image on page
  const x = (pageWidth - imgWidth) / 2;
  const y = 20; // 20mm from top
  
  // Add map image
  const imgData = canvas.toDataURL('image/jpeg', 0.95);
  doc.addImage(imgData, 'JPEG', x, y, imgWidth, imgHeight);
  
  // Add scale and north arrow (placeholder)
  doc.setFontSize(8);
  doc.text('N â†‘', pageWidth - 15, 15);
};

/**
 * Add parcel data pages to the PDF
 * @param {Object} doc - jsPDF document
 * @param {Array} parcels - Array of parcel objects
 */
const addParcelDataPages = (doc, parcels) => {
  // Add new page for parcel data
  doc.addPage();
  
  const pageWidth = doc.internal.pageSize.getWidth();
  
  // Add title
  doc.setFontSize(16);
  doc.text('Parcel Information', pageWidth / 2, 20, { align: 'center' });
  
  // Add parcel data
  let y = 40;
  
  parcels.forEach((parcel, index) => {
    // Check if we need a new page
    if (y > 250) {
      doc.addPage();
      y = 20;
    }
    
    // Add parcel header
    doc.setFontSize(12);
    doc.text(`Parcel ${index + 1}: ${parcel.name}`, 10, y);
    y += 10;
    
    // Add parcel details
    doc.setFontSize(10);
    
    if (parcel.metadata && parcel.metadata.createdAt) {
      const date = new Date(parcel.metadata.createdAt).toLocaleDateString();
      doc.text(`Created: ${date}`, 15, y);
      y += 7;
    }
    
    if (parcel.description) {
      doc.text('Description:', 15, y);
      y += 7;
      
      // Split long descriptions into multiple lines
      const descLines = doc.splitTextToSize(parcel.description, pageWidth - 30);
      doc.text(descLines, 20, y);
      y += 7 * descLines.length;
    }
    
    if (parcel.metadata && parcel.metadata.notes) {
      doc.text('Notes:', 15, y);
      y += 7;
      
      const noteLines = doc.splitTextToSize(parcel.metadata.notes, pageWidth - 30);
      doc.text(noteLines, 20, y);
      y += 7 * noteLines.length;
    }
    
    y += 10; // Space between parcels
  });
};

/**
 * Get scale factor based on resolution setting
 * @param {string} resolution - Resolution setting
 * @returns {number} - Scale factor
 */
const getResolutionScale = (resolution) => {
  switch (resolution) {
    case 'high':
      return 2;
    case 'print':
      return 3;
    case 'standard':
    default:
      return 1;
  }
};

/**
 * Trigger download of a blob
 * @param {Blob} blob - The blob to download
 * @param {string} fileName - File name
 */
export const downloadBlob = (blob, fileName) => {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = fileName;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};
